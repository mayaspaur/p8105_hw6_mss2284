---
title: "p8105_hw6_mss2284"
author: "Maya Spaur"
date: "11/16/2019"
output: github_document
---

```{r setup}
library(tidyverse)
library(modelr)
library(mgcv)
library(ggplot2)

```

#Problem 1

Load and tidy data: categorical variabels were converted into factor variables, and variables that had units in pounds (delwt, ppwt, wtgain) were converted to grams.

```{r}
data = 
  read_csv(file = "./data/birthweight.csv") %>%
  janitor::clean_names() %>%
  mutate(
    babysex = as.factor(babysex),
    frace = as.factor(frace),
    mrace = as.factor(mrace),
    delwt = 453.592*delwt,
    ppwt = 453.592*ppwt,
    wtgain = 453.592*wtgain
  )

```

In proposing a regression model for birthweight, I explore two different model-building processes. The first uses a data-driven model-building process, and the second uses a hypothesized structure and cross-validation.

Modeling process: hypothesis testing

Model 1. This process is data-driven and is based on the variables that are statistically significant. This is backward selection. 

Using all of the variables included in the dataset:

```{r modeling process}
model = lm(bwt ~ babysex + bhead + blength + delwt + fincome + frace + gaweeks + malform + menarche + mheight + momage + mrace + parity + pnumlbw + pnumsga + ppbmi + ppwt + smoken + wtgain, data = data)

model %>%
  broom::tidy() %>%
  knitr::kable(digits = 2)
```

Using this model-building process, the following variables were statistically significant (p < 0.05):

babysex2, bhead, blength, delwt, gaweeks, mrace2, parity, and smoken.

According to backward selection, a new model is run with these statistically significant variables to determine if they remain significant; the process is repeated until the remainder are all significant. 

#LEAPS library does this automatically, can use the function STEP. Provide an explicit explanation.

As displayed below, these variables remain significant in the restricted model and represent the proposed model: 

```{r}

proposed_model = lm(bwt ~ babysex+ bhead + blength + delwt + gaweeks+ mrace + parity + smoken, data = data)

proposed_model %>%
  broom::tidy() %>%
  knitr::kable(digits = 2)

```

Plot of model residuals against fitted values:

```{r}
scatter_plot =
  data %>% 
  modelr::add_residuals(proposed_model) %>% 
  modelr::add_predictions(proposed_model) %>%
  ggplot(aes(x = pred, y = resid)) + geom_point()

scatter_plot
```

I propose to include these statistically significant variables, babysex, bhead, blength, delwt, gaweeks, mrace, parity, and smoken in the model.



Main Effects Model

```{r main effects model}

main_effects = lm(bwt ~ blength + gaweeks, data = data)

main_effects %>%
  broom::tidy()

plot_main_effects =
  data %>% 
  modelr::add_residuals(main_effects) %>%
  modelr::add_predictions(main_effects) %>%
  ggplot(aes(x = pred, y = resid)) + geom_point()

plot_main_effects
```

Interaction Effects Model

```{r interaction model}

interaction_effects = lm(bwt ~ blength + gaweeks + (bhead*blength*babysex), data = data)

interaction_effects %>%
  broom::tidy()

plot_interaction_effects =
  data %>% 
  modelr::add_residuals(interaction_effects) %>%
  modelr::add_predictions(interaction_effects) %>%
  ggplot(aes(x = pred, y = resid)) + geom_point()

plot_interaction_effects
```

For the model containing babysex, bhead, blength, and the interactions between these variables, the interaction terms were statistically significant.


Compare models:

```{r comparing models}
cv_bwt_df =
  crossv_mc(data, 100) %>%
  mutate(
    train = map(train, as_tibble),
    test = map(test, as_tibble))

cv_bwt_df = 
  cv_bwt_df %>% 
  mutate(proposed_model  = map(train, ~lm(bwt ~ babysex+ bhead + blength + delwt + gaweeks+ mrace + parity + smoken, data = .x)),
         main_effects    = map(train, ~lm(bwt ~ blength + gaweeks, data = .x)),
         interaction_effects  = map(train, ~lm(bwt ~ blength + gaweeks + (bhead*blength*babysex), data = .x))) %>% 
  mutate(rmse_proposed = map2_dbl(proposed_model, test, ~rmse(model = .x, data = .y)),
         rmse_main_effects    = map2_dbl(main_effects, test, ~rmse(model = .x, data = .y)),
         rmse_interaction_effects = map2_dbl(interaction_effects, test, ~rmse(model = .x, data = .y)))


comparison_plot = 
  cv_bwt_df %>% 
  pivot_longer(
    rmse_proposed:rmse_interaction_effects,
    names_to = "model", 
    values_to = "rmse",
    names_prefix = "rmse_") %>% 
  mutate(model = fct_inorder(model)) %>% 
  ggplot(aes(x = model, y = rmse)) + geom_violin()

comparison_plot
```


Based on the plot above, the proposed model is the best model because it has the lowest RMSE values. Second best is the interaction_effects model, and the worst model is the main_effects model with the highest RMSE.

#Problem 2

#Error? How to adjust broom::tidy --> gives estimates for beta0 and beta1, can compute the log(beta0 and beta1 by creating a new column). have to pivot the estimate wider
#get CI by taking the percentiles

```{r, echo = FALSE}
weather_df = 
  rnoaa::meteo_pull_monitors(
    c("USW00094728"),
    var = c("PRCP", "TMIN", "TMAX"), 
    date_min = "2017-01-01",
    date_max = "2017-12-31") %>%
  mutate(
    name = recode(id, USW00094728 = "CentralPark_NY"),
    tmin = tmin / 10,
    tmax = tmax / 10) %>%
  select(name, id, everything())

```

Bootstraps

```{r}
set.seed(1)

boot_straps = 
  weather_df %>% 
  modelr::bootstrap(n = 10) %>%
  mutate(models = map(strap, ~lm(tmax ~ tmin, data = .x)),
         results = map(models, broom::glance),
         results_2 = map(models, broom::tidy)) %>%
  select(-strap, -models)  %>%
  janitor::clean_names()

boot_straps
```


Plot of Distribution of Estimates

#Do they mean a density plot?

r^2
```{r}
boot_straps_1 =
  boot_straps %>% 
  unnest(results) %>%
  ggplot(aes(x = r.squared)) + geom_density()

boot_straps_1

percentile_1 = 
  boot_straps %>% 
  unnest(results) %>%
    summarize(
    perc_2.5 = quantile(r.squared, 0.025),
    perc_90_1 = quantile(r.squared, 0.975)) %>%
  knitr::kable()

percentile_1

```

log(β^0∗β^1)

```{r}
boot_straps_2 =
  boot_straps %>% 
  unnest(results_2) %>%
  select(id, term, estimate) %>%
  pivot_wider(
    names_from = "term",
    values_from = "estimate"
  ) %>%
  janitor::clean_names() %>%
  mutate(log_term = log(intercept * tmin)) 

percentile_2 = 
  boot_straps_2 %>%
  summarize(
    perc_2.5 = quantile(log_term, 0.025),
    perc_90_1 = quantile(log_term, 0.975)) %>%
  knitr::kable()
  
percentile_2  

boot_straps_2_plot =
  boot_straps_2 %>%
  ggplot(aes(x = log_term)) + geom_density()

boot_straps_2_plot

```

